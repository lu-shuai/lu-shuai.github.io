<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="vue中Observer问题, 卢先森">
    <meta name="description" content="Vue.js - Day1课程介绍前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp后5天： 以项目驱动教学；
什么是Vue.js
Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（Re">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>vue中Observer问题 | 卢先森</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">卢先森</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">卢先森</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        vue中Observer问题
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/vue/" target="_blank">
                                <span class="chip bg-color">vue</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/前端/" class="post-category" target="_blank">
                                前端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-09-02
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="Vue-js-Day1"><a href="#Vue-js-Day1" class="headerlink" title="Vue.js - Day1"></a>Vue.js - Day1</h2><h4 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h4><p>前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp<br>后5天： 以项目驱动教学；</p>
<h6 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h6><ul>
<li><p>Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</p>
</li>
<li><p>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</p>
</li>
<li><p>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</p>
</li>
<li><p>前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；</p>
</li>
</ul>
<h4 id="为什么要学习流行框架"><a href="#为什么要学习流行框架" class="headerlink" title="为什么要学习流行框架"></a>为什么要学习流行框架</h4><ul>
<li>企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；<ul>
<li>企业中，使用框架，能够提高开发的效率；</li>
</ul>
</li>
</ul>
<ul>
<li>提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）</li>
<li>在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；</li>
</ul>
<ul>
<li>增强自己就业时候的竞争力<ul>
<li>人无我有，人有我优</li>
<li>你平时不忙的时候，都在干嘛？</li>
</ul>
</li>
</ul>
<h4 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h4><ul>
<li><p>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</p>
<ul>
<li>node 中的 express；</li>
</ul>
</li>
</ul>
<ul>
<li>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。<ul>
<li><ol>
<li>从Jquery 切换到 Zepto</li>
</ol>
</li>
<li><ol start="2">
<li>从 EJS 切换到 art-template</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别"><a href="#Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别" class="headerlink" title="Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别"></a>Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别</h4><ul>
<li><p>MVC 是后端的分层开发概念；</p>
</li>
<li><p>MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</p>
</li>
<li><p>为什么有了MVC还要有MVVM</p>
</li>
</ul>
<h4 id="Vue-js-基本代码-和-MVVM-之间的对应关系"><a href="#Vue-js-基本代码-和-MVVM-之间的对应关系" class="headerlink" title="Vue.js 基本代码 和 MVVM 之间的对应关系"></a>Vue.js 基本代码 和 MVVM 之间的对应关系</h4><h4 id="Vue之-基本的代码结构和插值表达式、v-cloak"><a href="#Vue之-基本的代码结构和插值表达式、v-cloak" class="headerlink" title="Vue之 - 基本的代码结构和插值表达式、v-cloak"></a>Vue之 - <code>基本的代码结构</code>和<code>插值表达式</code>、<code>v-cloak</code></h4><h4 id="Vue指令之v-text和v-html"><a href="#Vue指令之v-text和v-html" class="headerlink" title="Vue指令之v-text和v-html"></a>Vue指令之<code>v-text</code>和<code>v-html</code></h4><h4 id="Vue指令之v-bind的三种用法"><a href="#Vue指令之v-bind的三种用法" class="headerlink" title="Vue指令之v-bind的三种用法"></a>Vue指令之<code>v-bind</code>的三种用法</h4><ol>
<li><p>直接使用指令<code>v-bind</code></p>
</li>
<li><p>使用简化指令<code>:</code></p>
</li>
<li><p>在绑定的时候，拼接绑定内容：<code>:title="btnTitle + ', 这是追加的内容'"</code></p>
</li>
</ol>
<h4 id="Vue指令之v-on和跑马灯效果"><a href="#Vue指令之v-on和跑马灯效果" class="headerlink" title="Vue指令之v-on和跑马灯效果"></a>Vue指令之<code>v-on</code>和<code>跑马灯效果</code></h4><h6 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h6><ol>
<li>HTML结构：</li>
</ol>
<pre><code>
&lt;div id="app"&gt;

    &lt;p&gt;{{info}}&lt;/p&gt;

    &lt;input type="button" value="开启" v-on:click="go"&gt;

    &lt;input type="button" value="停止" v-on:click="stop"&gt;

  &lt;/div&gt;
</code></pre><ol start="2">
<li>Vue实例：</li>
</ol>
<pre><code>
    // 创建 Vue 实例，得到 ViewModel

    var vm = new Vue({

      el: '##app',

      data: {

        info: '猥琐发育，别浪~！',

        intervalId: null

      },

      methods: {

        go() {

          // 如果当前有定时器在运行，则直接return

          if (this.intervalId != null) {

            return;

          }

          // 开始定时器

          this.intervalId = setInterval(() =&gt; {

            this.info = this.info.substring(1) + this.info.substring(0, 1);

          }, 500);

        },

        stop() {

          clearInterval(this.intervalId);

        }

      }

    });
</code></pre><h4 id="Vue指令之v-on的缩写和事件修饰符"><a href="#Vue指令之v-on的缩写和事件修饰符" class="headerlink" title="Vue指令之v-on的缩写和事件修饰符"></a>Vue指令之<code>v-on的缩写</code>和<code>事件修饰符</code></h4><h6 id="事件修饰符："><a href="#事件修饰符：" class="headerlink" title="事件修饰符："></a>事件修饰符：</h6><ul>
<li><p>.stop       阻止冒泡</p>
</li>
<li><p>.prevent    阻止默认事件</p>
</li>
<li><p>.capture    添加事件侦听器时使用事件捕获模式</p>
</li>
<li><p>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</p>
</li>
<li><p>.once       事件只触发一次</p>
</li>
</ul>
<h4 id="Vue指令之v-model和双向数据绑定"><a href="#Vue指令之v-model和双向数据绑定" class="headerlink" title="Vue指令之v-model和双向数据绑定"></a>Vue指令之<code>v-model</code>和<code>双向数据绑定</code></h4><h4 id="简易计算器案例"><a href="#简易计算器案例" class="headerlink" title="简易计算器案例"></a>简易计算器案例</h4><ol>
<li>HTML 代码结构</li>
</ol>
<pre><code>
  &lt;div id="app"&gt;

    &lt;input type="text" v-model="n1"&gt;

    &lt;select v-model="opt"&gt;

      &lt;option value="0"&gt;+&lt;/option&gt;

      &lt;option value="1"&gt;-&lt;/option&gt;

      &lt;option value="2"&gt;*&lt;/option&gt;

      &lt;option value="3"&gt;÷&lt;/option&gt;

    &lt;/select&gt;

    &lt;input type="text" v-model="n2"&gt;

    &lt;input type="button" value="=" v-on:click="getResult"&gt;

    &lt;input type="text" v-model="result"&gt;

  &lt;/div&gt;
</code></pre><ol start="2">
<li>Vue实例代码：</li>
</ol>
<pre><code>
    // 创建 Vue 实例，得到 ViewModel

    var vm = new Vue({

      el: '##app',

      data: {

        n1: 0,

        n2: 0,

        result: 0,

        opt: '0'

      },

      methods: {

        getResult() {

          switch (this.opt) {

            case '0':

              this.result = parseInt(this.n1) + parseInt(this.n2);

              break;

            case '1':

              this.result = parseInt(this.n1) - parseInt(this.n2);

              break;

            case '2':

              this.result = parseInt(this.n1) * parseInt(this.n2);

              break;

            case '3':

              this.result = parseInt(this.n1) / parseInt(this.n2);

              break;

          }

        }

      }

    });
</code></pre><h4 id="在Vue中使用样式"><a href="#在Vue中使用样式" class="headerlink" title="在Vue中使用样式"></a>在Vue中使用样式</h4><h6 id="使用class样式"><a href="#使用class样式" class="headerlink" title="使用class样式"></a>使用class样式</h6><ol>
<li><p>数组</p>
<pre><code>&lt;h1 :class="['red', 'thin']"&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre></li>
<li><p>数组中使用三元表达式</p>
<pre><code>&lt;h1 :class="['red', 'thin', isactive?'active':'']"&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre></li>
<li><p>数组中嵌套对象</p>
<pre><code>&lt;h1 :class="['red', 'thin', {'active': isactive}]"&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre></li>
<li><p>直接使用对象</p>
<pre><code>&lt;h1 :class="{red:true, italic:true, active:true, thin:true}"&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre></li>
</ol>
<h6 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h6><ol>
<li><p>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</p>
<pre><code>&lt;h1 :style="{color: 'red', 'font-size': '40px'}"&gt;这是一个善良的H1&lt;/h1&gt;</code></pre></li>
<li><p>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</p>
<ul>
<li>在data上定义样式：<pre><code>data: {
   h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }
}</code></pre></li>
<li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<pre><code>&lt;h1 :style="h1StyleObj"&gt;这是一个善良的H1&lt;/h1&gt;</code></pre></li>
</ul>
</li>
<li><p>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</p>
<ul>
<li>在data上定义样式：<pre><code>data: {
   h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' },
   h1StyleObj2: { fontStyle: 'italic' }
}</code></pre></li>
<li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<pre><code>&lt;h1 :style="[h1StyleObj, h1StyleObj2]"&gt;这是一个善良的H1&lt;/h1&gt;</code></pre></li>
</ul>
</li>
</ol>
<h4 id="Vue指令之v-for和key属性"><a href="#Vue指令之v-for和key属性" class="headerlink" title="Vue指令之v-for和key属性"></a>Vue指令之<code>v-for</code>和<code>key</code>属性</h4><ol>
<li>迭代数组</li>
</ol>
<pre><code>&lt;ul&gt;
  &lt;li v-for="(item, i) in list"&gt;索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}&lt;/li&gt;
&lt;/ul&gt;</code></pre><ol start="2">
<li>迭代对象中的属性</li>
</ol>
<pre><code>
    &lt;!-- 循环遍历对象身上的属性 --&gt;

    &lt;div v-for="(val, key, i) in userInfo"&gt;{{val}} --- {{key}} --- {{i}}&lt;/div&gt;
</code></pre><ol start="3">
<li>迭代数字</li>
</ol>
<pre><code>
&lt;p v-for="i in 10"&gt;这是第 {{i}} 个P标签&lt;/p&gt;
</code></pre><blockquote>
<p>2.2.0+ 的版本里，<strong>当在组件中使用</strong> v-for 时，key 现在是必须的。</p>
</blockquote>
<p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p>
<p>为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p>
<h4 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h4><blockquote>
<p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p>
</blockquote>
<h4 id="品牌管理案例"><a href="#品牌管理案例" class="headerlink" title="品牌管理案例"></a>品牌管理案例</h4><h6 id="添加新品牌"><a href="#添加新品牌" class="headerlink" title="添加新品牌"></a>添加新品牌</h6><h6 id="删除品牌"><a href="#删除品牌" class="headerlink" title="删除品牌"></a>删除品牌</h6><h6 id="根据条件筛选品牌"><a href="#根据条件筛选品牌" class="headerlink" title="根据条件筛选品牌"></a>根据条件筛选品牌</h6><ol>
<li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li>
</ol>
<p><a href="https://v1-cn.vuejs.org/api/##filterBy" target="_blank" rel="noopener">filterBy - 指令</a></p>
<pre><code>
&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt;

  &lt;td&gt;{{item.id}}&lt;/td&gt;

  &lt;td&gt;{{item.name}}&lt;/td&gt;

  &lt;td&gt;{{item.ctime}}&lt;/td&gt;

  &lt;td&gt;

    &lt;a href="##" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt;

  &lt;/td&gt;

&lt;/tr&gt;
</code></pre><ol start="2">
<li>在2.x版本中<a href="https://cn.vuejs.org/v2/guide/list.html##显示过滤-排序结果" target="_blank" rel="noopener">手动实现筛选的方式</a>：</li>
</ol>
<ul>
<li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li>
</ul>
<pre><code>
&lt;hr&gt; 输入筛选名称：

&lt;input type="text" v-model="searchName"&gt;
</code></pre><ul>
<li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li>
</ul>
<pre><code>
&lt;tbody&gt;

      &lt;tr v-for="item in search(searchName)"&gt;

        &lt;td&gt;{{item.id}}&lt;/td&gt;

        &lt;td&gt;{{item.name}}&lt;/td&gt;

        &lt;td&gt;{{item.ctime}}&lt;/td&gt;

        &lt;td&gt;

          &lt;a href="##" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt;

        &lt;/td&gt;

      &lt;/tr&gt;

    &lt;/tbody&gt;
</code></pre><ul>
<li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li>
</ul>
<pre><code>
search(name) {

  return this.list.filter(x =&gt; {

    return x.name.indexOf(name) != -1;

  });

}
</code></pre><h4 id="Vue调试工具vue-devtools的安装步骤和使用"><a href="#Vue调试工具vue-devtools的安装步骤和使用" class="headerlink" title="Vue调试工具vue-devtools的安装步骤和使用"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h4><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p>
<h6 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h6><ol>
<li>HTML元素：</li>
</ol>
<pre><code>
&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt;
</code></pre><ol start="2">
<li>私有 <code>filters</code> 定义方式：</li>
</ol>
<pre><code>
filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用

    dataFormat(input, pattern = "") { // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错

      var dt = new Date(input);

      // 获取年月日

      var y = dt.getFullYear();

      var m = (dt.getMonth() + 1).toString().padStart(2, '0');

      var d = dt.getDate().toString().padStart(2, '0');



      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

      // 否则，就返回  年-月-日 时：分：秒

      if (pattern.toLowerCase() === 'yyyy-mm-dd') {

        return `${y}-${m}-${d}`;

      } else {

        // 获取时分秒

        var hh = dt.getHours().toString().padStart(2, '0');

        var mm = dt.getMinutes().toString().padStart(2, '0');

        var ss = dt.getSeconds().toString().padStart(2, '0');



        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;

      }

    }

  }
</code></pre><blockquote>
<p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p>
</blockquote>
<h6 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h6><pre><code>
// 定义一个全局过滤器

Vue.filter('dataFormat', function (input, pattern = '') {

  var dt = new Date(input);

  // 获取年月日

  var y = dt.getFullYear();

  var m = (dt.getMonth() + 1).toString().padStart(2, '0');

  var d = dt.getDate().toString().padStart(2, '0');



  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

  // 否则，就返回  年-月-日 时：分：秒

  if (pattern.toLowerCase() === 'yyyy-mm-dd') {

    return `${y}-${m}-${d}`;

  } else {

    // 获取时分秒

    var hh = dt.getHours().toString().padStart(2, '0');

    var mm = dt.getMinutes().toString().padStart(2, '0');

    var ss = dt.getSeconds().toString().padStart(2, '0');



    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;

  }

});
</code></pre><blockquote>
<p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p>
</blockquote>
<h4 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h4><h6 id="1-x中自定义键盘修饰符【了解即可】"><a href="#1-x中自定义键盘修饰符【了解即可】" class="headerlink" title="1.x中自定义键盘修饰符【了解即可】"></a>1.x中自定义键盘修饰符【了解即可】</h6><pre><code>
Vue.directive('on').keyCodes.f2 = 113;
</code></pre><h6 id="2-x中自定义键盘修饰符"><a href="#2-x中自定义键盘修饰符" class="headerlink" title="2.x中自定义键盘修饰符"></a><a href="https://cn.vuejs.org/v2/guide/events.html##键值修饰符" target="_blank" rel="noopener">2.x中自定义键盘修饰符</a></h6><ol>
<li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li>
</ol>
<pre><code>
Vue.config.keyCodes.f2 = 113;
</code></pre><ol start="2">
<li>使用自定义的按键修饰符：</li>
</ol>
<pre><code>
&lt;input type="text" v-model="name" @keyup.f2="add"&gt;
</code></pre><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></h4><ol>
<li>自定义全局和局部的 自定义指令：</li>
</ol>
<pre><code>
    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：

    Vue.directive('focus', {

      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用

        el.focus();

      }

    });



    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：

      directives: {

        color: { // 为元素设置指定的字体颜色

          bind(el, binding) {

            el.style.color = binding.value;

          }

        },

        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数

          el.style.fontWeight = binding2.value;

        }

      }
</code></pre><ol start="2">
<li>自定义指令的使用方式：</li>
</ol>
<pre><code>
&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt;
</code></pre><h4 id="Vue-1-x-中-自定义元素指令【已废弃-了解即可】"><a href="#Vue-1-x-中-自定义元素指令【已废弃-了解即可】" class="headerlink" title="Vue 1.x 中 自定义元素指令【已废弃,了解即可】"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h4><pre><code>Vue.elementDirective('red-color', {
  bind: function () {
    this.el.style.color = 'red';
  }
});</code></pre><p>使用方式：</p>
<pre><code>&lt;red-color&gt;1232&lt;/red-color&gt;</code></pre><h2 id="Vue-js-Day2"><a href="#Vue-js-Day2" class="headerlink" title="Vue.js - Day2"></a>Vue.js - Day2</h2><h4 id="品牌管理案例-1"><a href="#品牌管理案例-1" class="headerlink" title="品牌管理案例"></a>品牌管理案例</h4><h6 id="添加新品牌-1"><a href="#添加新品牌-1" class="headerlink" title="添加新品牌"></a>添加新品牌</h6><h6 id="删除品牌-1"><a href="#删除品牌-1" class="headerlink" title="删除品牌"></a>删除品牌</h6><h6 id="根据条件筛选品牌-1"><a href="#根据条件筛选品牌-1" class="headerlink" title="根据条件筛选品牌"></a>根据条件筛选品牌</h6><ol>
<li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li>
</ol>
<p><a href="https://v1-cn.vuejs.org/api/##filterBy" target="_blank" rel="noopener">filterBy - 指令</a></p>
<pre><code>
&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt;

  &lt;td&gt;{{item.id}}&lt;/td&gt;

  &lt;td&gt;{{item.name}}&lt;/td&gt;

  &lt;td&gt;{{item.ctime}}&lt;/td&gt;

  &lt;td&gt;

    &lt;a href="##" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt;

  &lt;/td&gt;

&lt;/tr&gt;
</code></pre><ol start="2">
<li>在2.x版本中<a href="https://cn.vuejs.org/v2/guide/list.html##显示过滤-排序结果" target="_blank" rel="noopener">手动实现筛选的方式</a>：</li>
</ol>
<ul>
<li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li>
</ul>
<pre><code>
&lt;hr&gt; 输入筛选名称：

&lt;input type="text" v-model="searchName"&gt;
</code></pre><ul>
<li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li>
</ul>
<pre><code>
&lt;tbody&gt;

      &lt;tr v-for="item in search(searchName)"&gt;

        &lt;td&gt;{{item.id}}&lt;/td&gt;

        &lt;td&gt;{{item.name}}&lt;/td&gt;

        &lt;td&gt;{{item.ctime}}&lt;/td&gt;

        &lt;td&gt;

          &lt;a href="##" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt;

        &lt;/td&gt;

      &lt;/tr&gt;

    &lt;/tbody&gt;
</code></pre><ul>
<li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li>
</ul>
<pre><code>
search(name) {

  return this.list.filter(x =&gt; {

    return x.name.indexOf(name) != -1;

  });

}
</code></pre><h4 id="Vue调试工具vue-devtools的安装步骤和使用-1"><a href="#Vue调试工具vue-devtools的安装步骤和使用-1" class="headerlink" title="Vue调试工具vue-devtools的安装步骤和使用"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h4><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p>
<h4 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h4><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p>
<h6 id="私有过滤器-1"><a href="#私有过滤器-1" class="headerlink" title="私有过滤器"></a>私有过滤器</h6><ol>
<li>HTML元素：</li>
</ol>
<pre><code>
&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt;
</code></pre><ol start="2">
<li>私有 <code>filters</code> 定义方式：</li>
</ol>
<pre><code>
filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用

    dataFormat(input, pattern = "") { // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错

      var dt = new Date(input);

      // 获取年月日

      var y = dt.getFullYear();

      var m = (dt.getMonth() + 1).toString().padStart(2, '0');

      var d = dt.getDate().toString().padStart(2, '0');



      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

      // 否则，就返回  年-月-日 时：分：秒

      if (pattern.toLowerCase() === 'yyyy-mm-dd') {

        return `${y}-${m}-${d}`;

      } else {

        // 获取时分秒

        var hh = dt.getHours().toString().padStart(2, '0');

        var mm = dt.getMinutes().toString().padStart(2, '0');

        var ss = dt.getSeconds().toString().padStart(2, '0');



        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;

      }

    }

  }
</code></pre><blockquote>
<p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p>
</blockquote>
<h6 id="全局过滤器-1"><a href="#全局过滤器-1" class="headerlink" title="全局过滤器"></a>全局过滤器</h6><pre><code>
// 定义一个全局过滤器

Vue.filter('dataFormat', function (input, pattern = '') {

  var dt = new Date(input);

  // 获取年月日

  var y = dt.getFullYear();

  var m = (dt.getMonth() + 1).toString().padStart(2, '0');

  var d = dt.getDate().toString().padStart(2, '0');



  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

  // 否则，就返回  年-月-日 时：分：秒

  if (pattern.toLowerCase() === 'yyyy-mm-dd') {

    return `${y}-${m}-${d}`;

  } else {

    // 获取时分秒

    var hh = dt.getHours().toString().padStart(2, '0');

    var mm = dt.getMinutes().toString().padStart(2, '0');

    var ss = dt.getSeconds().toString().padStart(2, '0');



    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;

  }

});
</code></pre><blockquote>
<p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p>
</blockquote>
<h4 id="键盘修饰符以及自定义键盘修饰符-1"><a href="#键盘修饰符以及自定义键盘修饰符-1" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h4><h6 id="1-x中自定义键盘修饰符【了解即可】-1"><a href="#1-x中自定义键盘修饰符【了解即可】-1" class="headerlink" title="1.x中自定义键盘修饰符【了解即可】"></a>1.x中自定义键盘修饰符【了解即可】</h6><pre><code>
Vue.directive('on').keyCodes.f2 = 113;
</code></pre><h6 id="2-x中自定义键盘修饰符-1"><a href="#2-x中自定义键盘修饰符-1" class="headerlink" title="2.x中自定义键盘修饰符"></a><a href="https://cn.vuejs.org/v2/guide/events.html##键值修饰符" target="_blank" rel="noopener">2.x中自定义键盘修饰符</a></h6><ol>
<li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li>
</ol>
<pre><code>
Vue.config.keyCodes.f2 = 113;
</code></pre><ol start="2">
<li>使用自定义的按键修饰符：</li>
</ol>
<pre><code>
&lt;input type="text" v-model="name" @keyup.f2="add"&gt;
</code></pre><h4 id="自定义指令-1"><a href="#自定义指令-1" class="headerlink" title="自定义指令"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></h4><ol>
<li>自定义全局和局部的 自定义指令：</li>
</ol>
<pre><code>
    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：

    Vue.directive('focus', {

      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用

        el.focus();

      }

    });



    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：

      directives: {

        color: { // 为元素设置指定的字体颜色

          bind(el, binding) {

            el.style.color = binding.value;

          }

        },

        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数

          el.style.fontWeight = binding2.value;

        }

      }
</code></pre><ol start="2">
<li>自定义指令的使用方式：</li>
</ol>
<pre><code>
&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt;
</code></pre><h4 id="Vue-1-x-中-自定义元素指令【已废弃-了解即可】-1"><a href="#Vue-1-x-中-自定义元素指令【已废弃-了解即可】-1" class="headerlink" title="Vue 1.x 中 自定义元素指令【已废弃,了解即可】"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h4><pre><code>Vue.elementDirective('red-color', {
  bind: function () {
    this.el.style.color = 'red';
  }
});</code></pre><p>使用方式：</p>
<pre><code>&lt;red-color&gt;1232&lt;/red-color&gt;</code></pre><h4 id="vue实例的生命周期"><a href="#vue实例的生命周期" class="headerlink" title="vue实例的生命周期"></a><a href="https://cn.vuejs.org/v2/guide/instance.html##实例生命周期" target="_blank" rel="noopener">vue实例的生命周期</a></h4><ul>
<li>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</li>
<li><a href="https://cn.vuejs.org/v2/api/##选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</li>
<li>生命周期钩子 = 生命周期函数 = 生命周期事件</li>
<li>主要的生命周期函数分类：<ul>
<li>创建期间的生命周期函数：<ul>
<li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li>
<li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li>
<li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li>
<li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
</ul>
</li>
<li>运行期间的生命周期函数：<ul>
<li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
</ul>
</li>
<li>销毁期间的生命周期函数：<ul>
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="vue-resource-实现-get-post-jsonp请求"><a href="#vue-resource-实现-get-post-jsonp请求" class="headerlink" title="vue-resource 实现 get, post, jsonp请求"></a><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">vue-resource 实现 get, post, jsonp请求</a></h4><p>除了 vue-resource 之外，还可以使用 <code>axios</code> 的第三方包实现实现数据的请求</p>
<ol>
<li><p>之前的学习中，如何发起数据请求？</p>
</li>
<li><p>常见的数据请求类型？  get  post jsonp</p>
</li>
<li><p>测试的URL请求资源地址：</p>
<ul>
<li>get请求地址： <a href="http://vue.studyit.io/api/getlunbo" target="_blank" rel="noopener">http://vue.studyit.io/api/getlunbo</a></li>
<li>post请求地址：<a href="http://vue.studyit.io/api/post" target="_blank" rel="noopener">http://vue.studyit.io/api/post</a></li>
<li>jsonp请求地址：<a href="http://vue.studyit.io/api/jsonp" target="_blank" rel="noopener">http://vue.studyit.io/api/jsonp</a></li>
</ul>
</li>
<li><p>JSONP的实现原理</p>
<ul>
<li><p>由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；</p>
</li>
<li><p>可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；</p>
</li>
<li><p>具体实现过程：</p>
<ul>
<li>先在客户端定义一个回调方法，预定义对数据的操作；</li>
<li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；</li>
<li>服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；</li>
<li>客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；</li>
</ul>
</li>
<li><p>带大家通过 Node.js ，来手动实现一个JSONP的请求例子；</p>
<pre><code>const http = require('http');
// 导入解析 URL 地址的核心模块
const urlModule = require('url');

const server = http.createServer();
// 监听 服务器的 request 请求事件，处理每个请求
server.on('request', (req, res) =&gt; {
 const url = req.url;

 // 解析客户端请求的URL地址
 var info = urlModule.parse(url, true);

 // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据
 if (info.pathname === '/getjsonp') {
   // 获取客户端指定的回调函数的名称
   var cbName = info.query.callback;
   // 手动拼接要返回给客户端的数据对象
   var data = {
     name: 'zs',
     age: 22,
     gender: '男',
     hobby: ['吃饭', '睡觉', '运动']
   }
   // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：
   var result = `${cbName}(${JSON.stringify(data)})`;
   // 将拼接好的方法的调用，返回给客户端去解析执行
   res.end(result);
 } else {
   res.end('404');
 }
});

server.listen(3000, () =&gt; {
 console.log('server running at http://127.0.0.1:3000');
});</code></pre></li>
</ul>
</li>
<li><p>vue-resource 的配置步骤：</p>
<ul>
<li>直接在页面中，通过<code>script</code>标签，引入 <code>vue-resource</code> 的脚本文件；</li>
<li>注意：引用的先后顺序是：先引用 <code>Vue</code> 的脚本文件，再引用 <code>vue-resource</code> 的脚本文件；</li>
</ul>
</li>
<li><p>发送get请求：</p>
<pre><code>getInfo() { // get 方式获取数据
this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; {
 console.log(res.body);
})
}</code></pre></li>
<li><p>发送post请求：</p>
<pre><code>postInfo() {
var url = 'http://127.0.0.1:8899/api/post';
// post 方法接收三个参数：
// 参数1： 要请求的URL地址
// 参数2： 要发送的数据对象
// 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded
this.$http.post(url, { name: 'zs' }, { emulateJSON: true }).then(res =&gt; {
 console.log(res.body);
});
}</code></pre></li>
<li><p>发送JSONP请求获取数据：</p>
<pre><code>jsonpInfo() { // JSONP形式从服务器获取数据
var url = 'http://127.0.0.1:8899/api/jsonp';
this.$http.jsonp(url).then(res =&gt; {
 console.log(res.body);
});
}</code></pre></li>
</ol>
<h4 id="配置本地数据库和数据接口API"><a href="#配置本地数据库和数据接口API" class="headerlink" title="配置本地数据库和数据接口API"></a>配置本地数据库和数据接口API</h4><ol>
<li>先解压安装 <code>PHPStudy</code>;</li>
<li>解压安装 <code>Navicat</code> 这个数据库可视化工具，并激活；</li>
<li>打开 <code>Navicat</code> 工具，新建空白数据库，名为 <code>dtcmsdb4</code>;</li>
<li>双击新建的数据库，连接上这个空白数据库，在新建的数据库上<code>右键</code> -&gt; <code>运行SQL文件</code>，选择并执行 <code>dtcmsdb4.sql</code> 这个数据库脚本文件；如果执行不报错，则数据库导入完成；</li>
<li>进入文件夹 <code>vuecms3_nodejsapi</code> 内部，执行 <code>npm i</code> 安装所有的依赖项；</li>
<li>先确保本机安装了 <code>nodemon</code>, 没有安装，则运行 <code>npm i nodemon -g</code> 进行全局安装，安装完毕后，进入到 <code>vuecms3_nodejsapi</code>目录 -&gt; <code>src</code>目录 -&gt; 双击运行 <code>start.bat</code></li>
<li>如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 <code>app.js</code> 中第 <code>14行</code> 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root</li>
</ol>
<h4 id="品牌管理改造"><a href="#品牌管理改造" class="headerlink" title="品牌管理改造"></a>品牌管理改造</h4><h6 id="展示品牌列表"><a href="#展示品牌列表" class="headerlink" title="展示品牌列表"></a>展示品牌列表</h6><h6 id="添加品牌数据"><a href="#添加品牌数据" class="headerlink" title="添加品牌数据"></a>添加品牌数据</h6><h6 id="删除品牌数据"><a href="#删除品牌数据" class="headerlink" title="删除品牌数据"></a>删除品牌数据</h6><h4 id="Vue中的动画"><a href="#Vue中的动画" class="headerlink" title="Vue中的动画"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Vue中的动画</a></h4><p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p>
<h6 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h6><ol>
<li><p>HTML结构：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;input type="button" value="动起来" @click="myAnimate"&gt;
 &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;
 &lt;transition name="fade"&gt;
   &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt;
 &lt;/transition&gt;
&lt;/div&gt;</code></pre></li>
<li><p>VM 实例：</p>
<pre><code>// 创建 Vue 实例，得到 ViewModel
var vm = new Vue({
el: '##app',
data: {
 isshow: false
},
methods: {
 myAnimate() {
   this.isshow = !this.isshow;
 }
}
});</code></pre></li>
<li><p>定义两组类样式：</p>
<pre><code>/* 定义进入和离开时候的过渡状态 */
 .fade-enter-active,
 .fade-leave-active {
   transition: all 0.2s ease;
   position: absolute;
 }

 /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */
 .fade-enter,
 .fade-leave-to {
   opacity: 0;
   transform: translateX(100px);
 }</code></pre></li>
</ol>
<h6 id="使用第三方-CSS-动画库"><a href="#使用第三方-CSS-动画库" class="headerlink" title="使用第三方 CSS 动画库"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html##自定义过渡类名" target="_blank" rel="noopener">使用第三方 CSS 动画库</a></h6><ol>
<li>导入动画类库：<pre><code>&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt;</code></pre></li>
<li>定义 transition 及属性：<pre><code>&lt;transition
 enter-active-class="fadeInRight"
 leave-active-class="fadeOutRight"
 :duration="{ enter: 500, leave: 800 }"&gt;
   &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;
&lt;/transition&gt;</code></pre></li>
</ol>
<h6 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h6><ol>
<li>定义 transition 组件以及三个钩子函数：<pre><code>&lt;div id="app"&gt;
 &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt;
 &lt;transition
 @before-enter="beforeEnter"
 @enter="enter"
 @after-enter="afterEnter"&gt;
   &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt;
 &lt;/transition&gt;
&lt;/div&gt;</code></pre></li>
<li>定义三个 methods 钩子方法：<pre><code>methods: {
     beforeEnter(el) { // 动画进入之前的回调
       el.style.transform = 'translateX(500px)';
     },
     enter(el, done) { // 动画进入完成时候的回调
       el.offsetWidth;
       el.style.transform = 'translateX(0px)';
       done();
     },
     afterEnter(el) { // 动画进入完成之后的回调
       this.isshow = !this.isshow;
     }
   }</code></pre></li>
<li>定义动画过渡时长和样式：<pre><code>.show{
   transition: all 0.4s ease;
 }</code></pre></li>
</ol>
<h6 id="v-for-的列表过渡"><a href="#v-for-的列表过渡" class="headerlink" title="v-for 的列表过渡"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html##列表的进入和离开过渡" target="_blank" rel="noopener">v-for 的列表过渡</a></h6><ol>
<li><p>定义过渡样式：</p>
<pre><code>&lt;style&gt;
 .list-enter,
 .list-leave-to {
   opacity: 0;
   transform: translateY(10px);
 }

 .list-enter-active,
 .list-leave-active {
   transition: all 0.3s ease;
 }
&lt;/style&gt;</code></pre></li>
<li><p>定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;input type="text" v-model="txt" @keyup.enter="add"&gt;

 &lt;transition-group tag="ul" name="list"&gt;
   &lt;li v-for="(item, i) in list" :key="i"&gt;{{item}}&lt;/li&gt;
 &lt;/transition-group&gt;
&lt;/div&gt;</code></pre></li>
<li><p>定义 VM中的结构：</p>
<pre><code> // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {
     txt: '',
     list: [1, 2, 3, 4]
   },
   methods: {
     add() {
       this.list.push(this.txt);
       this.txt = '';
     }
   }
 });</code></pre></li>
</ol>
<h6 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h6><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p>
<ul>
<li><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：<pre><code>.v-move{
transition: all 0.8s ease;
}
.v-leave-active{
position: absolute;
}</code></pre></li>
</ul>
<h2 id="Vue-js-Day3"><a href="#Vue-js-Day3" class="headerlink" title="Vue.js - Day3"></a>Vue.js - Day3</h2><h4 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h4><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p>
<ul>
<li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li>
<li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；<h6 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h6><ol>
<li>使用 Vue.extend 配合 Vue.component 方法：<pre><code>var login = Vue.extend({
template: '&lt;h1&gt;登录&lt;/h1&gt;'
});
Vue.component('login', login);</code></pre></li>
<li>直接使用 Vue.component 方法：<pre><code>Vue.component('register', {
template: '&lt;h1&gt;注册&lt;/h1&gt;'
});</code></pre></li>
<li>将模板字符串，定义到script标签种：<pre><code>&lt;script id="tmpl" type="x-template"&gt;
&lt;div&gt;&lt;a href="##"&gt;登录&lt;/a&gt; | &lt;a href="##"&gt;注册&lt;/a&gt;&lt;/div&gt;
&lt;/script&gt;</code></pre>同时，需要使用 Vue.component 来定义组件：<pre><code>Vue.component('account', {
template: '##tmpl'
});</code></pre></li>
</ol>
</li>
</ul>
<blockquote>
<p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p>
</blockquote>
<h6 id="组件中展示数据和响应事件"><a href="#组件中展示数据和响应事件" class="headerlink" title="组件中展示数据和响应事件"></a>组件中展示数据和响应事件</h6><ol>
<li>在组件中，<code>data</code>需要被定义为一个方法，例如：<pre><code>Vue.component('account', {
   template: '##tmpl',
   data() {
     return {
       msg: '大家好！'
     }
   },
   methods:{
     login(){
       alert('点击了登录按钮');
     }
   }
 });</code></pre></li>
<li>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</li>
</ol>
<h6 id="【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象"><a href="#【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象" class="headerlink" title="【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象"></a>【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象</h6><ol>
<li>通过计数器案例演示</li>
</ol>
<h6 id="使用components属性定义局部子组件"><a href="#使用components属性定义局部子组件" class="headerlink" title="使用components属性定义局部子组件"></a>使用<code>components</code>属性定义局部子组件</h6><ol>
<li>组件实例定义方式：<pre><code>&lt;script&gt;
 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {},
   methods: {},
   components: { // 定义子组件
     account: { // account 组件
       template: '&lt;div&gt;&lt;h1&gt;这是Account组件{{name}}&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;', // 在这里使用定义的子组件
       components: { // 定义子组件的子组件
         login: { // login 组件
           template: "&lt;h3&gt;这是登录组件&lt;/h3&gt;"
         }
       }
     }
   }
 });
&lt;/script&gt;</code></pre></li>
<li>引用组件：<pre><code>&lt;div id="app"&gt;
 &lt;account&gt;&lt;/account&gt;
&lt;/div&gt;</code></pre></li>
</ol>
<h4 id="使用flag标识符结合v-if和v-else切换组件"><a href="#使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="使用flag标识符结合v-if和v-else切换组件"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h4><ol>
<li><p>页面结构：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;input type="button" value="toggle" @click="flag=!flag"&gt;
 &lt;my-com1 v-if="flag"&gt;&lt;/my-com1&gt;
 &lt;my-com2 v-else="flag"&gt;&lt;/my-com2&gt;
&lt;/div&gt;</code></pre></li>
<li><p>Vue实例定义：</p>
<pre><code>&lt;script&gt;
 Vue.component('myCom1', {
   template: '&lt;h3&gt;奔波霸&lt;/h3&gt;'
 })

 Vue.component('myCom2', {
   template: '&lt;h3&gt;霸波奔&lt;/h3&gt;'
 })

 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {
     flag: true
   },
   methods: {}
 });
&lt;/script&gt;</code></pre></li>
</ol>
<h4 id="使用-is属性来切换不同的子组件-并添加切换动画"><a href="#使用-is属性来切换不同的子组件-并添加切换动画" class="headerlink" title="使用:is属性来切换不同的子组件,并添加切换动画"></a>使用<code>:is</code>属性来切换不同的子组件,并添加切换动画</h4><ol>
<li><p>组件实例定义方式：</p>
<pre><code>// 登录组件
 const login = Vue.extend({
   template: `&lt;div&gt;
     &lt;h3&gt;登录组件&lt;/h3&gt;
   &lt;/div&gt;`
 });
 Vue.component('login', login);

 // 注册组件
 const register = Vue.extend({
   template: `&lt;div&gt;
     &lt;h3&gt;注册组件&lt;/h3&gt;
   &lt;/div&gt;`
 });
 Vue.component('register', register);

 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: { comName: 'login' },
   methods: {}
 });</code></pre></li>
<li><p>使用<code>component</code>标签，来引用组件，并通过<code>:is</code>属性来指定要加载的组件：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;a href="##" @click.prevent="comName='login'"&gt;登录&lt;/a&gt;
 &lt;a href="##" @click.prevent="comName='register'"&gt;注册&lt;/a&gt;
 &lt;hr&gt;
 &lt;transition mode="out-in"&gt;
   &lt;component :is="comName"&gt;&lt;/component&gt;
 &lt;/transition&gt;
&lt;/div&gt;</code></pre></li>
<li><p>添加切换样式：</p>
<pre><code>&lt;style&gt;
 .v-enter,
 .v-leave-to {
   opacity: 0;
   transform: translateX(30px);
 }

 .v-enter-active,
 .v-leave-active {
   position: absolute;
   transition: all 0.3s ease;
 }

 h3{
   margin: 0;
 }
&lt;/style&gt;</code></pre></li>
</ol>
<h4 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h4><ol>
<li>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据<pre><code>&lt;script&gt;
 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {
     msg: '这是父组件中的消息'
   },
   components: {
     son: {
       template: '&lt;h1&gt;这是子组件 --- {{finfo}}&lt;/h1&gt;',
       props: ['finfo']
     }
   }
 });
&lt;/script&gt;</code></pre></li>
<li>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：<pre><code>&lt;div id="app"&gt;
 &lt;son :finfo="msg"&gt;&lt;/son&gt;
&lt;/div&gt;</code></pre></li>
</ol>
<h4 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h4><ol>
<li><p>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</p>
</li>
<li><p>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</p>
<pre><code>&lt;son @func="getMsg"&gt;&lt;/son&gt;</code></pre></li>
<li><p>子组件内部通过<code>this.$emit('方法名', 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</p>
<pre><code>&lt;div id="app"&gt;
 &lt;!-- 引用父组件 --&gt;
 &lt;son @func="getMsg"&gt;&lt;/son&gt;

 &lt;!-- 组件模板定义 --&gt;
 &lt;script type="x-template" id="son"&gt;
   &lt;div&gt;
     &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt;
   &lt;/div&gt;
 &lt;/script&gt;
&lt;/div&gt;

&lt;script&gt;
 // 子组件的定义方式
 Vue.component('son', {
   template: '##son', // 组件模板Id
   methods: {
     sendMsg() { // 按钮的点击事件
       this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去
     }
   }
 });

 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {},
   methods: {
     getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义
       alert(val);
     }
   }
 });
&lt;/script&gt;</code></pre></li>
</ol>
<h4 id="评论列表案例"><a href="#评论列表案例" class="headerlink" title="评论列表案例"></a>评论列表案例</h4><p>目标：主要练习父子组件之间传值</p>
<h4 id="使用-this-refs-来获取元素和组件"><a href="#使用-this-refs-来获取元素和组件" class="headerlink" title="使用 this.$refs 来获取元素和组件"></a>使用 <code>this.$refs</code> 来获取元素和组件</h4><pre><code>  &lt;div id="app"&gt;
    &lt;div&gt;
      &lt;input type="button" value="获取元素内容" @click="getElement" /&gt;
      &lt;!-- 使用 ref 获取元素 --&gt;
      &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt;

      &lt;hr&gt;
      &lt;!-- 使用 ref 获取子组件 --&gt;
      &lt;my-com ref="mycom"&gt;&lt;/my-com&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script&gt;
    Vue.component('my-com', {
      template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;',
      data() {
        return {
          name: '子组件'
        }
      }
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '##app',
      data: {},
      methods: {
        getElement() {
          // 通过 this.$refs 来获取元素
          console.log(this.$refs.myh1.innerText);
          // 通过 this.$refs 来获取组件
          console.log(this.$refs.mycom.name);
        }
      }
    });
  &lt;/script&gt;</code></pre><h4 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h4><ol>
<li><p>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p>
</li>
<li><p>对于单页面应用程序来说，主要通过URL中的hash(##号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p>
</li>
<li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p>
</li>
</ol>
<h4 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h4><ol>
<li><p>导入 vue-router 组件类库：</p>
<pre><code>&lt;!-- 1. 导入 vue-router 组件类库 --&gt;
&lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt;</code></pre></li>
<li><p>使用 router-link 组件来导航</p>
<pre><code>&lt;!-- 2. 使用 router-link 组件来导航 --&gt;
&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;
&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;</code></pre></li>
<li><p>使用 router-view 组件来显示匹配到的组件</p>
<pre><code>&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;
&lt;router-view&gt;&lt;/router-view&gt;</code></pre></li>
<li><p>创建使用<code>Vue.extend</code>创建组件</p>
<pre><code> // 4.1 使用 Vue.extend 来创建登录组件
 var login = Vue.extend({
   template: '&lt;h1&gt;登录组件&lt;/h1&gt;'
 });

 // 4.2 使用 Vue.extend 来创建注册组件
 var register = Vue.extend({
   template: '&lt;h1&gt;注册组件&lt;/h1&gt;'
 });</code></pre></li>
<li><p>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p>
<pre><code>// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则
 var router = new VueRouter({
   routes: [
     { path: '/login', component: login },
     { path: '/register', component: register }
   ]
 });</code></pre></li>
<li><p>使用 router 属性来使用路由规则</p>
<pre><code>// 6. 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   router: router // 使用 router 属性来使用路由规则
 });</code></pre></li>
</ol>
<h4 id="设置路由高亮"><a href="#设置路由高亮" class="headerlink" title="设置路由高亮"></a>设置路由高亮</h4><h4 id="设置路由切换动效"><a href="#设置路由切换动效" class="headerlink" title="设置路由切换动效"></a>设置路由切换动效</h4><h4 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h4><ol>
<li>在规则中定义参数：<pre><code>{ path: '/register/:id', component: register }</code></pre></li>
<li>通过 <code>this.$route.params</code>来获取路由中的参数：<pre><code>var register = Vue.extend({
   template: '&lt;h1&gt;注册组件 --- {{this.$route.params.id}}&lt;/h1&gt;'
 });</code></pre></li>
</ol>
<h4 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h4><pre><code>  &lt;div id="app"&gt;
    &lt;router-link to="/account"&gt;Account&lt;/router-link&gt;

    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 父路由中的组件
    const account = Vue.extend({
      template: `&lt;div&gt;
        这是account组件
        &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | 
        &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
      &lt;/div&gt;`
    });

    // 子路由中的 login 组件
    const login = Vue.extend({
      template: '&lt;div&gt;登录组件&lt;/div&gt;'
    });

    // 子路由中的 register 组件
    const register = Vue.extend({
      template: '&lt;div&gt;注册组件&lt;/div&gt;'
    });

    // 路由实例
    var router = new VueRouter({
      routes: [
        { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向
        {
          path: '/account',
          component: account,
          children: [ // 通过 children 数组属性，来实现路由的嵌套
            { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符
            { path: 'register', component: register }
          ]
        }
      ]
    });

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '##app',
      data: {},
      methods: {},
      components: {
        account
      },
      router: router
    });
  &lt;/script&gt;</code></pre><h4 id="命名视图实现经典布局"><a href="#命名视图实现经典布局" class="headerlink" title="命名视图实现经典布局"></a>命名视图实现经典布局</h4><ol>
<li><p>标签代码结构：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;router-view&gt;&lt;/router-view&gt;
 &lt;div class="content"&gt;
   &lt;router-view name="a"&gt;&lt;/router-view&gt;
   &lt;router-view name="b"&gt;&lt;/router-view&gt;
 &lt;/div&gt;
&lt;/div&gt;</code></pre></li>
<li><p>JS代码：</p>
<pre><code>&lt;script&gt;
 var header = Vue.component('header', {
   template: '&lt;div class="header"&gt;header&lt;/div&gt;'
 });

 var sidebar = Vue.component('sidebar', {
   template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;'
 });

 var mainbox = Vue.component('mainbox', {
   template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;'
 });

 // 创建路由对象
 var router = new VueRouter({
   routes: [
     {
       path: '/', components: {
         default: header,
         a: sidebar,
         b: mainbox
       }
     }
   ]
 });

 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {},
   methods: {},
   router
 });
&lt;/script&gt;</code></pre></li>
<li><p>CSS 样式：</p>
<pre><code>&lt;style&gt;
 .header {
   border: 1px solid red;
 }

 .content{
   display: flex;
 }
 .sidebar {
   flex: 2;
   border: 1px solid green;
   height: 500px;
 }
 .mainbox{
   flex: 8;
   border: 1px solid blue;
   height: 500px;
 }
&lt;/style&gt;</code></pre></li>
</ol>
<h4 id="watch属性的使用"><a href="#watch属性的使用" class="headerlink" title="watch属性的使用"></a><code>watch</code>属性的使用</h4><p>考虑一个问题：想要实现 <code>名</code> 和 <code>姓</code> 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）</p>
<ol>
<li><p>监听<code>data</code>中属性的改变：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;input type="text" v-model="firstName"&gt; +
 &lt;input type="text" v-model="lastName"&gt; =
 &lt;span&gt;{{fullName}}&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {
     firstName: 'jack',
     lastName: 'chen',
     fullName: 'jack - chen'
   },
   methods: {},
   watch: {
     'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据
       this.fullName = newVal + ' - ' + this.lastName;
     },
     'lastName': function (newVal, oldVal) {
       this.fullName = this.firstName + ' - ' + newVal;
     }
   }
 });
&lt;/script&gt;</code></pre></li>
<li><p>监听路由对象的改变：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;router-link to="/login"&gt;登录&lt;/router-link&gt;
 &lt;router-link to="/register"&gt;注册&lt;/router-link&gt;

 &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;

&lt;script&gt;
 var login = Vue.extend({
   template: '&lt;h1&gt;登录组件&lt;/h1&gt;'
 });

 var register = Vue.extend({
   template: '&lt;h1&gt;注册组件&lt;/h1&gt;'
 });

 var router = new VueRouter({
   routes: [
     { path: "/login", component: login },
     { path: "/register", component: register }
   ]
 });

 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {},
   methods: {},
   router: router,
   watch: {
     '$route': function (newVal, oldVal) {
       if (newVal.path === '/login') {
         console.log('这是登录组件');
       }
     }
   }
 });
&lt;/script&gt;</code></pre></li>
</ol>
<h4 id="computed计算属性的使用"><a href="#computed计算属性的使用" class="headerlink" title="computed计算属性的使用"></a><code>computed</code>计算属性的使用</h4><ol>
<li><p>默认只有<code>getter</code>的计算属性：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;input type="text" v-model="firstName"&gt; +
 &lt;input type="text" v-model="lastName"&gt; =
 &lt;span&gt;{{fullName}}&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {
     firstName: 'jack',
     lastName: 'chen'
   },
   methods: {},
   computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值
     fullName() {
       return this.firstName + ' - ' + this.lastName;
     }
   }
 });
&lt;/script&gt;</code></pre></li>
<li><p>定义有<code>getter</code>和<code>setter</code>的计算属性：</p>
<pre><code>&lt;div id="app"&gt;
 &lt;input type="text" v-model="firstName"&gt;
 &lt;input type="text" v-model="lastName"&gt;
 &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt;
 &lt;input type="button" value="修改fullName" @click="changeName"&gt;

 &lt;span&gt;{{fullName}}&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '##app',
   data: {
     firstName: 'jack',
     lastName: 'chen'
   },
   methods: {
     changeName() {
       this.fullName = 'TOM - chen2';
     }
   },
   computed: {
     fullName: {
       get: function () {
         return this.firstName + ' - ' + this.lastName;
       },
       set: function (newVal) {
         var parts = newVal.split(' - ');
         this.firstName = parts[0];
         this.lastName = parts[1];
       }
     }
   }
 });
&lt;/script&gt;</code></pre></li>
</ol>
<h4 id="watch、computed和methods之间的对比"><a href="#watch、computed和methods之间的对比" class="headerlink" title="watch、computed和methods之间的对比"></a><code>watch</code>、<code>computed</code>和<code>methods</code>之间的对比</h4><ol>
<li><code>computed</code>属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li>
<li><code>methods</code>方法表示一个具体的操作，主要书写业务逻辑；</li>
<li><code>watch</code>一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是<code>computed</code>和<code>methods</code>的结合体；</li>
</ol>
<h4 id="nrm的安装使用"><a href="#nrm的安装使用" class="headerlink" title="nrm的安装使用"></a><code>nrm</code>的安装使用</h4><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；<br>什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；</p>
<ol>
<li>运行<code>npm i nrm -g</code>全局安装<code>nrm</code>包；</li>
<li>使用<code>nrm ls</code>查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</li>
<li>使用<code>nrm use npm</code>或<code>nrm use taobao</code>切换不同的镜像源地址；</li>
</ol>
<h2 id="Vue-js-Day5-Webpack"><a href="#Vue-js-Day5-Webpack" class="headerlink" title="Vue.js - Day5 - Webpack"></a>Vue.js - Day5 - Webpack</h2><h4 id="在网页中会引用哪些常见的静态资源？"><a href="#在网页中会引用哪些常见的静态资源？" class="headerlink" title="在网页中会引用哪些常见的静态资源？"></a>在网页中会引用哪些常见的静态资源？</h4><ul>
<li>JS<ul>
<li>.js  .jsx  .coffee  .ts（TypeScript  类 C## 语言）</li>
</ul>
</li>
<li>CSS<ul>
<li>.css  .less   .sass  .scss</li>
</ul>
</li>
<li>Images<ul>
<li>.jpg   .png   .gif   .bmp   .svg</li>
</ul>
</li>
<li>字体文件（Fonts）<ul>
<li>.svg   .ttf   .eot   .woff   .woff2</li>
</ul>
</li>
<li>模板文件<ul>
<li>.ejs   .jade  .vue【这是在webpack中定义组件的方式，推荐这么用】</li>
</ul>
</li>
</ul>
<h4 id="网页中引入的静态资源多了以后有什么问题？？？"><a href="#网页中引入的静态资源多了以后有什么问题？？？" class="headerlink" title="网页中引入的静态资源多了以后有什么问题？？？"></a>网页中引入的静态资源多了以后有什么问题？？？</h4><ol>
<li>网页加载速度慢， 因为 我们要发起很多的二次请求；</li>
<li>要处理错综复杂的依赖关系</li>
</ol>
<h4 id="如何解决上述两个问题"><a href="#如何解决上述两个问题" class="headerlink" title="如何解决上述两个问题"></a>如何解决上述两个问题</h4><ol>
<li>合并、压缩、精灵图、图片的Base64编码</li>
<li>可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；</li>
</ol>
<h4 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack?"></a>什么是webpack?</h4><p>webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；</p>
<h4 id="如何完美实现上述的2种解决方案"><a href="#如何完美实现上述的2种解决方案" class="headerlink" title="如何完美实现上述的2种解决方案"></a>如何完美实现上述的2种解决方案</h4><ol>
<li>使用Gulp， 是基于 task 任务的；</li>
<li>使用Webpack， 是基于整个项目进行构建的；</li>
</ol>
<ul>
<li>借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。</li>
<li>根据官网的图片介绍webpack打包的过程</li>
<li><a href="http://webpack.github.io/" target="_blank" rel="noopener">webpack官网</a></li>
</ul>
<h4 id="webpack安装的两种方式"><a href="#webpack安装的两种方式" class="headerlink" title="webpack安装的两种方式"></a>webpack安装的两种方式</h4><ol>
<li>运行<code>npm i webpack -g</code>全局安装webpack，这样就能在全局使用webpack的命令</li>
<li>在项目根目录中运行<code>npm i webpack --save-dev</code>安装到项目依赖中</li>
</ol>
<h4 id="初步使用webpack打包构建列表隔行变色案例"><a href="#初步使用webpack打包构建列表隔行变色案例" class="headerlink" title="初步使用webpack打包构建列表隔行变色案例"></a>初步使用webpack打包构建列表隔行变色案例</h4><ol>
<li><p>运行<code>npm init</code>初始化项目，使用npm管理项目中的依赖包</p>
</li>
<li><p>创建项目基本的目录结构</p>
</li>
<li><p>使用<code>cnpm i jquery --save</code>安装jquery类库</p>
</li>
<li><p>创建<code>main.js</code>并书写各行变色的代码逻辑：</p>
<pre><code> // 导入jquery类库
 import $ from 'jquery'

 // 设置偶数行背景色，索引从0开始，0是偶数
 $('##list li:even').css('backgroundColor','lightblue');
 // 设置奇数行背景色
 $('##list li:odd').css('backgroundColor','pink');</code></pre></li>
<li><p>直接在页面上引用<code>main.js</code>会报错，因为浏览器不认识<code>import</code>这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；</p>
</li>
<li><p>运行<code>webpack 入口文件路径 输出文件路径</code>对<code>main.js</code>进行处理：</p>
<pre><code>webpack src/js/main.js dist/bundle.js</code></pre></li>
</ol>
<h4 id="使用webpack的配置文件简化打包时候的命令"><a href="#使用webpack的配置文件简化打包时候的命令" class="headerlink" title="使用webpack的配置文件简化打包时候的命令"></a>使用webpack的配置文件简化打包时候的命令</h4><ol>
<li><p>在项目根目录中创建<code>webpack.config.js</code></p>
</li>
<li><p>由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在<code>webpack.config.js</code>中配置这两个路径：</p>
<pre><code> // 导入处理路径的模块
 var path = require('path');

 // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理
 module.exports = {
     entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件
     output: { // 配置输出选项
         path: path.resolve(__dirname, 'dist'), // 配置输出的路径
         filename: 'bundle.js' // 配置输出的文件名
     }
 }</code></pre></li>
</ol>
<h4 id="实现webpack的实时打包构建"><a href="#实现webpack的实时打包构建" class="headerlink" title="实现webpack的实时打包构建"></a>实现webpack的实时打包构建</h4><ol>
<li>由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用<code>webpack-dev-server</code>来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。</li>
<li>运行<code>cnpm i webpack-dev-server --save-dev</code>安装到开发依赖</li>
<li>安装完成之后，在命令行直接运行<code>webpack-dev-server</code>来进行打包，发现报错，此时需要借助于<code>package.json</code>文件中的指令，来进行运行<code>webpack-dev-server</code>命令，在<code>scripts</code>节点下新增<code>"dev": "webpack-dev-server"</code>指令，发现可以进行实时打包，但是dist目录下并没有生成<code>bundle.js</code>文件，这是因为<code>webpack-dev-server</code>将打包好的文件放在了内存中<ul>
<li>把<code>bundle.js</code>放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快</li>
<li>这个时候访问webpack-dev-server启动的<code>http://localhost:8080/</code>网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:<code>&lt;script src="../bundle.js"&gt;&lt;/script&gt;</code></li>
<li>为了能在访问<code>http://localhost:8080/</code>的时候直接访问到index首页，可以使用<code>--contentBase src</code>指令来修改dev指令，指定启动的根目录：<pre><code>"dev": "webpack-dev-server --contentBase src"</code></pre>同时修改index页面中script的src属性为<code>&lt;script src="bundle.js"&gt;&lt;/script&gt;</code></li>
</ul>
</li>
</ol>
<h4 id="使用html-webpack-plugin插件配置启动页面"><a href="#使用html-webpack-plugin插件配置启动页面" class="headerlink" title="使用html-webpack-plugin插件配置启动页面"></a>使用<code>html-webpack-plugin</code>插件配置启动页面</h4><p>由于使用<code>--contentBase</code>指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用<code>html-webpack-plugin</code>插件配置启动页面.</p>
<ol>
<li><p>运行<code>cnpm i html-webpack-plugin --save-dev</code>安装到开发依赖</p>
</li>
<li><p>修改<code>webpack.config.js</code>配置文件如下：</p>
<pre><code> // 导入处理路径的模块
 var path = require('path');
 // 导入自动生成HTMl文件的插件
 var htmlWebpackPlugin = require('html-webpack-plugin');

 module.exports = {
     entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件
     output: { // 配置输出选项
         path: path.resolve(__dirname, 'dist'), // 配置输出的路径
         filename: 'bundle.js' // 配置输出的文件名
     },
     plugins:[ // 添加plugins节点配置插件
         new htmlWebpackPlugin({
             template:path.resolve(__dirname, 'src/index.html'),//模板路径
             filename:'index.html'//自动生成的HTML文件的名称
         })
     ]
 }</code></pre></li>
<li><p>修改<code>package.json</code>中<code>script</code>节点中的dev指令如下：</p>
<pre><code>"dev": "webpack-dev-server"</code></pre></li>
<li><p>将index.html中script标签注释掉，因为<code>html-webpack-plugin</code>插件会自动把bundle.js注入到index.html页面中！</p>
</li>
</ol>
<h4 id="实现自动打开浏览器、热更新和配置浏览器的默认端口号"><a href="#实现自动打开浏览器、热更新和配置浏览器的默认端口号" class="headerlink" title="实现自动打开浏览器、热更新和配置浏览器的默认端口号"></a>实现自动打开浏览器、热更新和配置浏览器的默认端口号</h4><p><strong>注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！</strong></p>
<h6 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h6><ul>
<li>修改<code>package.json</code>的script节点如下，其中<code>--open</code>表示自动打开浏览器，<code>--port 4321</code>表示打开的端口号为4321，<code>--hot</code>表示启用浏览器热更新：<pre><code>"dev": "webpack-dev-server --hot --port 4321 --open"</code></pre></li>
</ul>
<h6 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h6><ol>
<li>修改<code>webpack.config.js</code>文件，新增<code>devServer</code>节点如下：<pre><code>devServer:{
     hot:true,
     open:true,
     port:4321
 }</code></pre></li>
<li>在头部引入<code>webpack</code>模块：<pre><code>var webpack = require('webpack');</code></pre></li>
<li>在<code>plugins</code>节点下新增：<pre><code>new webpack.HotModuleReplacementPlugin()</code></pre></li>
</ol>
<h4 id="使用webpack打包css文件"><a href="#使用webpack打包css文件" class="headerlink" title="使用webpack打包css文件"></a>使用webpack打包css文件</h4><ol>
<li>运行<code>cnpm i style-loader css-loader --save-dev</code></li>
<li>修改<code>webpack.config.js</code>这个配置文件：<pre><code>module: { // 用来配置第三方loader模块的
     rules: [ // 文件的匹配规则
         { test: /\.css$/, use: ['style-loader', 'css-loader'] }//处理css文件的规则
     ]
 }</code></pre></li>
<li>注意：<code>use</code>表示使用哪些模块来处理<code>test</code>所匹配到的文件；<code>use</code>中相关loader模块的调用顺序是从后向前调用的；</li>
</ol>
<h4 id="使用webpack打包less文件"><a href="#使用webpack打包less文件" class="headerlink" title="使用webpack打包less文件"></a>使用webpack打包less文件</h4><ol>
<li>运行<code>cnpm i less-loader less -D</code></li>
<li>修改<code>webpack.config.js</code>这个配置文件：<pre><code>{ test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },</code></pre></li>
</ol>
<h4 id="使用webpack打包sass文件"><a href="#使用webpack打包sass文件" class="headerlink" title="使用webpack打包sass文件"></a>使用webpack打包sass文件</h4><ol>
<li>运行<code>cnpm i sass-loader node-sass --save-dev</code></li>
<li>在<code>webpack.config.js</code>中添加处理sass文件的loader模块：<pre><code>{ test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }</code></pre></li>
</ol>
<h4 id="使用webpack处理css中的路径"><a href="#使用webpack处理css中的路径" class="headerlink" title="使用webpack处理css中的路径"></a>使用webpack处理css中的路径</h4><ol>
<li>运行<code>cnpm i url-loader file-loader --save-dev</code></li>
<li>在<code>webpack.config.js</code>中添加处理url路径的loader模块：<pre><code>{ test: /\.(png|jpg|gif)$/, use: 'url-loader' }</code></pre></li>
<li>可以通过<code>limit</code>指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：<pre><code>{ test: /\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' },</code></pre></li>
</ol>
<h4 id="使用babel处理高级JS语法"><a href="#使用babel处理高级JS语法" class="headerlink" title="使用babel处理高级JS语法"></a>使用babel处理高级JS语法</h4><ol>
<li>运行<code>cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev</code>安装babel的相关loader包</li>
<li>运行<code>cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev</code>安装babel转换的语法</li>
<li>在<code>webpack.config.js</code>中添加相关loader模块，其中需要注意的是，一定要把<code>node_modules</code>文件夹添加到排除项：<pre><code>{ test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ }</code></pre></li>
<li>在项目根目录中添加<code>.babelrc</code>文件，并修改这个配置文件如下：<pre><code>{
 "presets":["es2015", "stage-0"],
 "plugins":["transform-runtime"]
}</code></pre></li>
<li><strong>注意：语法插件<code>babel-preset-es2015</code>可以更新为<code>babel-preset-env</code>，它包含了所有的ES相关的语法；</strong></li>
</ol>
<h2 id="Vue-js-day6"><a href="#Vue-js-day6" class="headerlink" title="Vue.js - day6"></a>Vue.js - day6</h2><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>有时候使用<code>npm i node-sass -D</code>装不上，这时候，就必须使用 <code>cnpm i node-sass -D</code></p>
<h4 id="在普通页面中使用render函数渲染组件"><a href="#在普通页面中使用render函数渲染组件" class="headerlink" title="在普通页面中使用render函数渲染组件"></a>在普通页面中使用render函数渲染组件</h4><h4 id="在webpack中配置-vue组件页面的解析"><a href="#在webpack中配置-vue组件页面的解析" class="headerlink" title="在webpack中配置.vue组件页面的解析"></a>在webpack中配置.vue组件页面的解析</h4><ol>
<li><p>运行<code>cnpm i vue -S</code>将vue安装为运行依赖；</p>
</li>
<li><p>运行<code>cnpm i vue-loader vue-template-compiler -D</code>将解析转换vue的包安装为开发依赖；</p>
</li>
<li><p>运行<code>cnpm i style-loader css-loader -D</code>将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式；</p>
</li>
<li><p>在<code>webpack.config.js</code>中，添加如下<code>module</code>规则：</p>
</li>
</ol>
<pre><code>
module: {

    rules: [

      { test: /\.css$/, use: ['style-loader', 'css-loader'] },

      { test: /\.vue$/, use: 'vue-loader' }

    ]

  }
</code></pre><ol start="5">
<li>创建<code>App.js</code>组件页面：</li>
</ol>
<pre><code>
    &lt;template&gt;

      &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt;

      &lt;div&gt;

        &lt;h1&gt;这是APP组件 - {{msg}}&lt;/h1&gt;

        &lt;h3&gt;我是h3&lt;/h3&gt;

      &lt;/div&gt;

    &lt;/template&gt;



    &lt;script&gt;

    // 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象

    export default {

      data() {

        return {

          msg: 'OK'

        }

      }

    }

    &lt;/script&gt;



    &lt;style scoped&gt;

    h1 {

      color: red;

    }

    &lt;/style&gt;
</code></pre><ol start="6">
<li>创建<code>main.js</code>入口文件：</li>
</ol>
<pre><code>
    // 导入 Vue 组件

    import Vue from 'vue'



    // 导入 App组件

    import App from './components/App.vue'



    // 创建一个 Vue 实例，使用 render 函数，渲染指定的组件

    var vm = new Vue({

      el: '##app',

      render: c =&gt; c(App)

    });
</code></pre><h4 id="在使用webpack构建的Vue项目中使用模板对象？"><a href="#在使用webpack构建的Vue项目中使用模板对象？" class="headerlink" title="在使用webpack构建的Vue项目中使用模板对象？"></a>在使用webpack构建的Vue项目中使用模板对象？</h4><ol>
<li>在<code>webpack.config.js</code>中添加<code>resolve</code>属性：<pre><code>resolve: {
 alias: {
   'vue$': 'vue/dist/vue.esm.js'
 }
}</code></pre></li>
</ol>
<h4 id="ES6中语法使用总结"><a href="#ES6中语法使用总结" class="headerlink" title="ES6中语法使用总结"></a>ES6中语法使用总结</h4><ol>
<li><p>使用 <code>export default</code> 和 <code>export</code> 导出模块中的成员; 对应ES5中的 <code>module.exports</code> 和 <code>export</code></p>
</li>
<li><p>使用 <code>import ** from **</code> 和 <code>import '路径'</code> 还有 <code>import {a, b} from '模块标识'</code> 导入其他模块</p>
</li>
<li><p>使用箭头函数：<code>(a, b)=&gt; { return a-b; }</code></p>
</li>
</ol>
<h4 id="在vue组件页面中，集成vue-router路由模块"><a href="#在vue组件页面中，集成vue-router路由模块" class="headerlink" title="在vue组件页面中，集成vue-router路由模块"></a>在vue组件页面中，集成vue-router路由模块</h4><p><a href="https://router.vuejs.org/" target="_blank" rel="noopener">vue-router官网</a></p>
<ol>
<li>导入路由模块：</li>
</ol>
<pre><code>
import VueRouter from 'vue-router'
</code></pre><ol start="2">
<li>安装路由模块：</li>
</ol>
<pre><code>
Vue.use(VueRouter);
</code></pre><ol start="3">
<li>导入需要展示的组件:</li>
</ol>
<pre><code>
import login from './components/account/login.vue'

import register from './components/account/register.vue'
</code></pre><ol start="4">
<li>创建路由对象:</li>
</ol>
<pre><code>
var router = new VueRouter({

  routes: [

    { path: '/', redirect: '/login' },

    { path: '/login', component: login },

    { path: '/register', component: register }

  ]

});
</code></pre><ol start="5">
<li>将路由对象，挂载到 Vue 实例上:</li>
</ol>
<pre><code>
var vm = new Vue({

  el: '##app',

  // render: c =&gt; { return c(App) }

  render(c) {

    return c(App);

  },

  router // 将路由对象，挂载到 Vue 实例上

});
</code></pre><ol start="6">
<li>改造App.vue组件，在 template 中，添加<code>router-link</code>和<code>router-view</code>：</li>
</ol>
<pre><code>
    &lt;router-link to="/login"&gt;登录&lt;/router-link&gt;

    &lt;router-link to="/register"&gt;注册&lt;/router-link&gt;



    &lt;router-view&gt;&lt;/router-view&gt;
</code></pre><h4 id="组件中的css作用域问题"><a href="#组件中的css作用域问题" class="headerlink" title="组件中的css作用域问题"></a>组件中的css作用域问题</h4><h4 id="抽离路由为单独的模块"><a href="#抽离路由为单独的模块" class="headerlink" title="抽离路由为单独的模块"></a>抽离路由为单独的模块</h4><h4 id="使用-饿了么的-MintUI-组件"><a href="#使用-饿了么的-MintUI-组件" class="headerlink" title="使用 饿了么的 MintUI 组件"></a>使用 饿了么的 MintUI 组件</h4><p><a href="https://github.com/ElemeFE/mint-ui" target="_blank" rel="noopener">Github 仓储地址</a></p>
<p><a href="http://mint-ui.github.io/##!/zh-cn" target="_blank" rel="noopener">Mint-UI官方文档</a></p>
<ol>
<li>导入所有MintUI组件：</li>
</ol>
<pre><code>
import MintUI from 'mint-ui'
</code></pre><ol start="2">
<li>导入样式表：</li>
</ol>
<pre><code>
import 'mint-ui/lib/style.css'
</code></pre><ol start="3">
<li>在 vue 中使用 MintUI：</li>
</ol>
<pre><code>
Vue.use(MintUI)
</code></pre><ol start="4">
<li>使用的例子：</li>
</ol>
<pre><code>
&lt;mt-button type="primary" size="large"&gt;primary&lt;/mt-button&gt;
</code></pre><h4 id="使用-MUI-组件"><a href="#使用-MUI-组件" class="headerlink" title="使用 MUI 组件"></a>使用 MUI 组件</h4><p><a href="http://dev.dcloud.net.cn/mui/" target="_blank" rel="noopener">官网首页</a></p>
<p><a href="http://dev.dcloud.net.cn/mui/ui/" target="_blank" rel="noopener">文档地址</a></p>
<ol>
<li>导入 MUI 的样式表：</li>
</ol>
<pre><code>
import '../lib/mui/css/mui.min.css'
</code></pre><ol start="2">
<li>在<code>webpack.config.js</code>中添加新的loader规则：</li>
</ol>
<pre><code>
{ test: /\.(png|jpg|gif|ttf)$/, use: 'url-loader' }
</code></pre><ol start="3">
<li>根据官方提供的文档和example，尝试使用相关的组件</li>
</ol>
<h4 id="将项目源码托管到oschina中"><a href="#将项目源码托管到oschina中" class="headerlink" title="将项目源码托管到oschina中"></a>将项目源码托管到oschina中</h4><ol>
<li><p>点击头像 -&gt; 修改资料 -&gt; SSH公钥 <a href="http://git.mydoc.io/?t=154712" target="_blank" rel="noopener">如何生成SSH公钥</a></p>
</li>
<li><p>创建自己的空仓储，使用 <code>git config --global user.name "用户名"</code> 和 <code>git config --global user.email ***@**.com</code> 来全局配置提交时用户的名称和邮箱</p>
</li>
<li><p>使用 <code>git init</code> 在本地初始化项目</p>
</li>
<li><p>使用 <code>touch README.md</code> 和 <code>touch .gitignore</code> 来创建项目的说明文件和忽略文件；</p>
</li>
<li><p>使用 <code>git add .</code> 将所有文件托管到 git 中</p>
</li>
<li><p>使用 <code>git commit -m "init project"</code> 将项目进行本地提交</p>
</li>
<li><p>使用 <code>git remote add origin 仓储地址</code>将本地项目和远程仓储连接，并使用origin最为远程仓储的别名</p>
</li>
<li><p>使用 <code>git push -u origin master</code> 将本地代码push到仓储中</p>
</li>
</ol>
<h4 id="App-vue-组件的基本设置"><a href="#App-vue-组件的基本设置" class="headerlink" title="App.vue 组件的基本设置"></a>App.vue 组件的基本设置</h4><ol>
<li><p>头部的固定导航栏使用 <code>Mint-UI</code> 的 <code>Header</code> 组件；</p>
</li>
<li><p>底部的页签使用 <code>mui</code> 的 <code>tabbar</code>;</p>
</li>
<li><p>购物车的图标，使用 <code>icons-extra</code> 中的 <code>mui-icon-extra mui-icon-extra-cart</code>，同时，应该把其依赖的字体图标文件 <code>mui-icons-extra.ttf</code>，复制到 <code>fonts</code> 目录下！</p>
</li>
<li><p>将底部的页签，改造成 <code>router-link</code> 来实现单页面的切换；</p>
</li>
<li><p>Tab Bar 路由激活时候设置高亮的两种方式：</p>
<ul>
<li>全局设置样式如下：</li>
</ul>
<pre><code>
  .router-link-active{

       color:##007aff !important;

 }
</code></pre><ul>
<li>或者在 <code>new VueRouter</code> 的时候，通过 <code>linkActiveClass</code> 来指定高亮的类：</li>
</ul>
<pre><code>
  // 创建路由对象

 var router = new VueRouter({

   routes: [

     { path: '/', redirect: '/home' }

   ],

   linkActiveClass: 'mui-active'

 });
</code></pre></li>
</ol>
<h4 id="实现-tabbar-页签不同组件页面的切换"><a href="#实现-tabbar-页签不同组件页面的切换" class="headerlink" title="实现 tabbar 页签不同组件页面的切换"></a>实现 tabbar 页签不同组件页面的切换</h4><ol>
<li><p>将 tabbar 改造成 <code>router-link</code> 形式，并指定每个连接的 <code>to</code> 属性；</p>
</li>
<li><p>在入口文件中导入需要展示的组件，并创建路由对象：</p>
</li>
</ol>
<pre><code>
    // 导入需要展示的组件

    import Home from './components/home/home.vue'

    import Member from './components/member/member.vue'

    import Shopcar from './components/shopcar/shopcar.vue'

    import Search from './components/search/search.vue'



    // 创建路由对象

    var router = new VueRouter({

      routes: [

        { path: '/', redirect: '/home' },

        { path: '/home', component: Home },

        { path: '/member', component: Member },

        { path: '/shopcar', component: Shopcar },

        { path: '/search', component: Search }

      ],

      linkActiveClass: 'mui-active'

    });
</code></pre><h4 id="使用-mt-swipe-轮播图组件"><a href="#使用-mt-swipe-轮播图组件" class="headerlink" title="使用 mt-swipe 轮播图组件"></a>使用 mt-swipe 轮播图组件</h4><ol>
<li>假数据：</li>
</ol>
<pre><code>
lunbo: [

        'http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg',

        'http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg',

        'http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg'

      ]
</code></pre><ol start="2">
<li>引入轮播图组件：</li>
</ol>
<pre><code>
&lt;!-- Mint-UI 轮播图组件 --&gt;

    &lt;div class="home-swipe"&gt;

      &lt;mt-swipe :auto="4000"&gt;

        &lt;mt-swipe-item v-for="(item, i) in lunbo" :key="i"&gt;

          &lt;img :src="item" alt=""&gt;

        &lt;/mt-swipe-item&gt;

      &lt;/mt-swipe&gt;

    &lt;/div&gt;

  &lt;/div&gt;
</code></pre><h4 id="在-vue组件中使用vue-resource获取数据"><a href="#在-vue组件中使用vue-resource获取数据" class="headerlink" title="在.vue组件中使用vue-resource获取数据"></a>在<code>.vue</code>组件中使用<code>vue-resource</code>获取数据</h4><ol>
<li><p>运行<code>cnpm i vue-resource -S</code>安装模块</p>
</li>
<li><p>导入 vue-resource 组件</p>
</li>
</ol>
<pre><code>
import VueResource from 'vue-resource'
</code></pre><ol start="3">
<li>在vue中使用 vue-resource 组件</li>
</ol>
<pre><code>
Vue.use(VueResource);
</code></pre><h2 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h2><h4 id="使用mui的tab-top-webview-main完成分类滑动栏"><a href="#使用mui的tab-top-webview-main完成分类滑动栏" class="headerlink" title="使用mui的tab-top-webview-main完成分类滑动栏"></a>使用mui的<code>tab-top-webview-main</code>完成分类滑动栏</h4><h6 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h6><ol>
<li><p>和 App.vue 中的 <code>router-link</code> 身上的类名 <code>mui-tab-item</code> 存在兼容性问题，导致tab栏失效，可以把<code>mui-tab-item</code>改名为<code>mui-tab-item1</code>，并复制相关的类样式，来解决这个问题；</p>
<pre><code> .mui-bar-tab .mui-tab-item1.mui-active {
   color: ##007aff;
 }

 .mui-bar-tab .mui-tab-item1 {
   display: table-cell;
   overflow: hidden;
   width: 1%;
   height: 50px;
   text-align: center;
   vertical-align: middle;
   white-space: nowrap;
   text-overflow: ellipsis;
   color: ##929292;
 }

 .mui-bar-tab .mui-tab-item1 .mui-icon {
   top: 3px;
   width: 24px;
   height: 24px;
   padding-top: 0;
   padding-bottom: 0;
 }

 .mui-bar-tab .mui-tab-item1 .mui-icon~.mui-tab-label {
   font-size: 11px;
   display: block;
   overflow: hidden;
   text-overflow: ellipsis;
 }</code></pre></li>
<li><p><code>tab-top-webview-main</code>组件第一次显示到页面中的时候，无法被滑动的解决方案：</p>
<ul>
<li>先导入 mui 的JS文件:<pre><code>import mui from '../../../lib/mui/js/mui.min.js'</code></pre></li>
<li>在 组件的 <code>mounted</code> 事件钩子中，注册 mui 的滚动事件：<pre><code>mounted() {
   // 需要在组件的 mounted 事件钩子中，注册 mui 的 scroll 滚动事件
   mui('.mui-scroll-wrapper').scroll({
     deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006
   });
 }</code></pre></li>
</ul>
</li>
<li><p>滑动的时候报警告：<code>Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080</code></p>
<pre><code>解决方法，可以加上* { touch-action: none; } 这句样式去掉。</code></pre><p>原因：（是chrome为了提高页面的滑动流畅度而新折腾出来的一个东西） <a href="http://www.cnblogs.com/pearl07/p/6589114.html" target="_blank" rel="noopener">http://www.cnblogs.com/pearl07/p/6589114.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action</a></p>
</li>
</ol>
<h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><ol>
<li><a href="https://v1-cn.vuejs.org/" target="_blank" rel="noopener">vue.js 1.x 文档</a></li>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js 2.x 文档</a></li>
<li><a href="http://www.css88.com/archives/7715" target="_blank" rel="noopener">String.prototype.padStart(maxLength, fillString)</a></li>
<li><a href="http://www.cnblogs.com/wuhua1/p/6686237.html" target="_blank" rel="noopener">js 里面的键盘事件对应的键码</a></li>
<li><a href="http://www.cnblogs.com/kidney/p/6052935.html" target="_blank" rel="noopener">Vue.js双向绑定的实现原理</a></li>
<li><a href="https://jingyan.baidu.com/article/a65957f4976aad24e67f9b9b.html" target="_blank" rel="noopener">navicat如何导入sql文件和导出sql文件</a></li>
<li><a href="http://cubic-bezier.com/##.4,-0.3,1,.33" target="_blank" rel="noopener">贝塞尔在线生成器</a></li>
<li><a href="http://www.cnblogs.com/joyho/articles/4430148.html" target="_blank" rel="noopener">URL中的hash（井号）</a></li>
<li><a href="https://segmentfault.com/p/1210000008466178" target="_blank" rel="noopener">babel-preset-env：你需要的唯一Babel插件</a></li>
<li><a href="https://segmentfault.com/a/1190000009065987" target="_blank" rel="noopener">Runtime transform 运行时编译es6</a></li>
<li><a href="https://github.com/LS1231/vue-preview" target="_blank" rel="noopener">vue-preview</a><br>一个Vue集成PhotoSwipe图片预览插件</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《vue中Observer问题》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2019/09/02/vue/vuelearning/" property="cc:attributionName"
               rel="cc:attributionURL">
                卢先森
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6 overflow-policy" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2019/09/02/vue/vuelearning/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="vue中Observer问题">
                        
                        <span class="card-title">vue中Observer问题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Vue.js - Day1课程介绍前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp后5天： 以项目驱动教学；
什么是Vue.js
Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（Re
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-09-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/前端/" class="post-category" target="_blank">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/vue/" target="_blank">
                        <span class="chip bg-color">vue</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6 overflow-policy" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/08/29/node/01-web-concept/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="node学习">
                        
                        <span class="card-title">node学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            第1章 服务端开发基础学习目标

什么是服务器
什么是 Web 服务器
IP、DNS、端口号的作用
命令行的使用

在浏览器输入一个地址到看到网站内容经历了什么
用户在浏览器地址栏中输入网站域名
浏览器拿到该域名自动去请求 DNS服务器查询
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-08-29
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/node/" class="post-category" target="_blank">
                                    node
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/node/" target="_blank">
                        <span class="chip bg-color">node</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            <!-- 本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建. -->

            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:1441086355@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1441086355" class="tooltipped" data-tooltip="QQ联系我: 1441086355" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>